---
description: Error handling — exceptions, global handler, validation
globs: "**/*.java"
alwaysApply: false
---

# Error Handling

## Not-found in services

Use the shared exception from `common.exception`:

```java
// In a service: when entity is missing
Prop prop = repository.findById(id)
    .orElseThrow(() -> new ResourceNotFoundException("Prop", id));
```

- **ResourceNotFoundException**(String message) — custom message.
- **ResourceNotFoundException**(String resourceName, Object id) — produces: `"{ResourceName} with id [id] not found"`.
- It is `@ResponseStatus(HttpStatus.NOT_FOUND)`; the global handler maps it to RFC 7807 ProblemDetail.

## Global handler

- **GlobalExceptionHandler** (`@RestControllerAdvice`) in `common.exception` returns **ProblemDetail** (RFC 7807) for all API errors.
- Handled: `ResourceNotFoundException`, `MethodArgumentNotValidException`, `BindException`, `HttpMessageNotReadableException`, `AccessDeniedException`, `AuthenticationException`, and a generic `Exception` fallback.
- Do not add controller-level `@ExceptionHandler` for these; keep handling in the global handler.

## Validation

- Request DTOs: use Jakarta Validation on records (e.g. `@NotBlank`, `@Size`, `@Positive`). Controllers use `@Valid @RequestBody` so validation runs before the service; failures are turned into ProblemDetail with a `errors` list of field/message pairs by the global handler.
- Use meaningful messages (e.g. `message = "Name is required"`) for client-facing errors.

## Throwing errors

- In services: throw `ResourceNotFoundException` for missing resources. For other domain/validation failures, throw a clear runtime exception that the global handler can map, or extend the handler for new exception types.
